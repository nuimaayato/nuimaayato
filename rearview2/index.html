<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>RearView 2 - 捕食者のナワバリ</title>
    <style>
        :root { --bg: #030205; --blood: #cc0000; --ui-bg: rgba(0, 0, 0, 0.9); }
        body { margin: 0; background: var(--bg); color: #fff; font-family: "Hiragino Mincho ProN", serif; overflow: hidden; user-select: none; }
        canvas { display: block; margin: auto; background: #000; }
        #entryUI { position: absolute; inset: 0; background: #000; display: flex; align-items: center; justify-content: center; z-index: 200; }
        #entryUI button { all: unset; cursor: pointer; color: var(--blood); font-size: 2rem; letter-spacing: 0.5rem; text-shadow: 0 0 15px #f00; }
        #titleUI { position: absolute; inset: 0; background: url('image_0.png') no-repeat center center; background-size: cover; display: none; align-items: center; justify-content: center; z-index: 100; }
        .menuWrap { background: rgba(0,0,0,0.85); padding: 30px 50px; border: 1px solid var(--blood); border-radius: 10px; text-align: center; width: 300px; }
        button { all: unset; cursor: pointer; color: #eee; font-size: 1.1rem; padding: 10px; display: block; transition: 0.3s; width: 100%; border-bottom: 1px solid transparent; }
        button:hover { color: var(--blood); border-bottom: 1px solid var(--blood); }
        .vol-ctrl { margin-top: 15px; color: #888; font-size: 0.8rem; }
        #prologue, #ending { position: absolute; inset: 0; background: #000; display: none; align-items: center; justify-content: center; z-index: 150; opacity: 0; transition: opacity 1.2s; cursor: pointer; }
        .inner-text { width: 75%; line-height: 2.2; font-size: 1.2rem; color: #eee; text-align: center; white-space: pre-wrap; }
        
        /* ゲームオーバーウィンドウ */
        #gameOverUI { position: absolute; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 300; }
        .dead-window { background: #050000; border: 2px solid var(--blood); padding: 40px; text-align: center; box-shadow: 0 0 30px #f00; border-radius: 5px; }
        .dead-msg { color: #f00; font-size: 1.3rem; margin-bottom: 25px; line-height: 2; white-space: pre-wrap; }

        .hud { position: absolute; inset: 0; pointer-events: none; display: none; }
        .status-panel { position: absolute; top: 20px; left: 20px; width: 220px; background: var(--ui-bg); border-left: 4px solid var(--blood); padding: 15px; }
        .mirror-container { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); width: 480px; height: 100px; background: #050505; border: 4px solid #444; border-radius: 40px / 15px; overflow: hidden; box-shadow: 0 5px 25px #000; }
        .bar-wrap { height: 12px; background: #222; margin-bottom: 8px; border: 1px solid #444; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.3s ease-out; }
        #hp-fill { background: linear-gradient(to right, #600, #f00); }
        #dist-fill { background: #00eeff; }
    </style>
</head>
<body>

<div id="entryUI"><button onclick="entryGame()">……潜入する</button></div>

<div id="titleUI">
    <div class="menuWrap">
        <h1 style="color:red; font-size:1.8rem; margin-bottom:15px;">リヤビュー 2</h1>
        <button onclick="startStory(1)">スポットへ行く</button>
        <button onclick="alert('霊を喰らう怪異のナワバリ。逃げ切れるか。')">あらすじ</button>
        <div class="vol-ctrl">音量設定<br><input type="range" min="0" max="1" step="0.1" value="0.5" oninput="setVolume(this.value)"></div>
        <button onclick="window.close()" style="margin-top:10px;">終わる</button>
    </div>
</div>

<div id="gameOverUI">
    <div class="dead-window">
        <div class="dead-msg" id="dead-quote"></div>
        <div id="retry-btn-container"></div>
    </div>
</div>

<div id="prologue" onclick="proceedStory()"><div class="inner-text" id="story-text"></div></div>
<div id="ending" onclick="proceedEnding()"><div class="inner-text" id="ending-text"></div></div>

<div class="hud" id="gameHUD">
    <div class="status-panel">
        <div id="enemy-name" style="font-size: 1.2rem; color:red; font-weight:900; margin-bottom:10px;">-</div>
        <div class="bar-wrap"><div id="hp-fill" class="bar-fill"></div></div>
        <div style="font-size: 0.8rem; color:#888;">目的地まで</div>
        <div class="bar-wrap"><div id="dist-fill" class="bar-fill"></div></div>
        <div style="color: #888; font-size: 0.8rem;">リトライ残数: <span id="retry-count">3</span></div>
    </div>
    <div class="mirror-container"><canvas id="mirrorCv" width="480" height="100"></canvas></div>
</div>
<canvas id="mainCv"></canvas>

<audio id="bgmTitle" src="タイトル.mp3" loop></audio>
<audio id="bgmStage1" src="こっくりさん.mp3" loop></audio>
<audio id="bgmStage2" src="八尺様mp3.mp3" loop></audio>
<audio id="bgmStage3" src="ターボババアmp3.mp3" loop></audio>
<audio id="bgmStage4" src="テケテケ.mp3" loop></audio>
<audio id="bgmStage5" src="口裂け女.mp3" loop></audio>

<script>
const canvas = document.getElementById("mainCv");
const ctx = canvas.getContext("2d");
const mCv = document.getElementById("mirrorCv");
const mctx = mCv.getContext("2d");
canvas.width = 960; canvas.height = 600;

const stageTexts = {
    1: ["……また、この静寂だ。\n廃校の教室から、逃げ出さなくては。", "十円玉が震える音だけが響く。", "止まるな。"],
    2: ["廃校を抜けた先、そこは市街地の外れだった。", "ポポポ、ポポポ……\n奴の白い腕が、すぐそこまで届いている。"],
    3: ["……速い。並走してくる老婆。", "ターボババアだ。\n一瞬の判断ミスが死を招く。"],
    4: ["深夜の高架下。カサカサと腕で這う音。", "テケテケだ。下半身を奪われる前に逃げ切れ。"],
    5: ["目的地まではまだ遠い。住宅街に潜む影。", "「私、きれい……？」\n凶悪なハサミが闇を切り裂く。"]
};

// ステージごとの都市伝説セリフ3行
const monsterQuotes = {
    1: "「手が、動かない……」\n「死について聞いたのはお前か？」\n「コックリさんは、すぐ後ろに」",
    2: "「ポ……ポ……ポ……」\n「逃げられると思ったのか？」\n「魅入られたら、もうおしまい」",
    3: "「速いね……でも、私の方が速いよ」\n「もっと、アクセルを踏みなよ」\n「ずっと、隣を走ってあげる」",
    4: "「私の足、知らない？」\n「お前の足、いい形してるね」\n「テケ……テケ……テケ……」",
    5: "「私、きれい……？」\n「これでも、きれい……？」\n「……さあ、お前も同じにしてあげる」"
};

const endingLines = [
    "朝日が、住宅街の向こうから昇り始めた。",
    "背後を振り返る。そこにはもう、誰もいない。",
    "耳鳴りのように響いていたあの声も、今は消えた。",
    "……すべては、夢だったのだろうか。",
    "だが、ポケットに入った十円玉は、ひどく冷たい。",
    "ナワバリを抜けた。生きて帰ることができたのだ。",
    "しかし、この恐怖は、いつかまた繰り返されるだろう。",
    "正しさの外側で蠢く者たちは、常に隣にいるのだから。",
    "リヤビューに映る景色が、また揺れた気がした。",
    "RearView 2 - 完"
];

let lastTime = 0, storyIdx = 0, currentStage = 1, retries = 3, endIdx = 0;
const VELOCITY = { scroll: 400, player: 550, obstacle: 600 };
let game = { active: false, hp: 5, maxHp: 5, time: 0, px: 480, py: 540, dist: 0, goal: 30000, state: 'chase', timer: 0, attackType: '', shake: 0, freeze: 0, obstacles: [], targetX: 0, targetY: 0, dmg: 1 };
const keys = {};

function setVolume(v) { document.querySelectorAll('audio').forEach(a => a.volume = v); }
function entryGame() { document.getElementById('entryUI').style.display='none'; document.getElementById('titleUI').style.display='flex'; document.getElementById('bgmTitle').play(); }
function stopAllBGM() { [1,2,3,4,5].forEach(i => { const a = document.getElementById('bgmStage'+i); if(a){a.pause(); a.currentTime=0;} }); document.getElementById('bgmTitle').pause(); }

function startStory(stageNum) {
    game.active = false; // ループ停止
    currentStage = stageNum; storyIdx = 0; stopAllBGM();
    const bgm = document.getElementById('bgmStage' + currentStage); if(bgm) bgm.play();
    document.getElementById('titleUI').style.display = 'none';
    const p = document.getElementById('prologue'); p.style.display = 'flex';
    setTimeout(() => p.style.opacity = 1, 50); renderStory();
}
function renderStory() { document.getElementById('story-text').innerText = stageTexts[currentStage][storyIdx] + "\n\n（クリックで次へ）"; }
function proceedStory() {
    storyIdx++;
    if (storyIdx < stageTexts[currentStage].length) renderStory();
    else { document.getElementById('prologue').style.opacity = 0; setTimeout(() => { document.getElementById('prologue').style.display = 'none'; initGame(); }, 800); }
}

function initGame() {
    document.getElementById('gameOverUI').style.display = 'none';
    game.active = true; game.time = 0; game.dist = 0; game.state = 'chase'; game.obstacles = [];
    if(currentStage === 3) game.maxHp = 6; else if(currentStage === 4) game.maxHp = 7; else if(currentStage === 5) game.maxHp = 10; else game.maxHp = 5;
    game.hp = game.maxHp; game.goal = (currentStage === 5) ? 60000 : 30000;
    document.getElementById('retry-count').innerText = retries; document.getElementById('gameHUD').style.display = 'block';
    const names = ["", "コックリさん", "八尺様", "ターボババア", "テケテケ", "口裂け女"];
    document.getElementById('enemy-name').innerText = names[currentStage];
    
    // ★リトライ対策: 開始の瞬間に時間を合わせる
    lastTime = performance.now();
    requestAnimationFrame(loop);
}

const ROAD_START_Y = 120;
function getRoadX(y, time) {
    const progress = game.dist / game.goal;
    const centerX = 480; let curveIntensity = progress * 400;
    if (currentStage === 3 && progress < 0.6) return centerX;
    const p = (y - ROAD_START_Y) / (600 - ROAD_START_Y);
    return centerX + Math.sin(time * 2.5 + p * 2) * curveIntensity * p;
}

function showGameOverWindow() {
    game.active = false;
    const ui = document.getElementById('gameOverUI');
    const msg = document.getElementById('dead-quote');
    const btnContainer = document.getElementById('retry-btn-container');
    
    ui.style.display = 'flex';
    msg.innerText = monsterQuotes[currentStage];
    
    if (retries > 0) {
        btnContainer.innerHTML = `<button onclick="retries--; initGame()">リトライ (${retries})</button>`;
    } else {
        btnContainer.innerHTML = `<button onclick="location.reload()">タイトルへ戻る</button>`;
    }
}

function update(dt) {
    if (!game.active) return;
    game.time += dt; game.dist += VELOCITY.scroll * dt;
    if (game.freeze > 0) game.freeze -= dt;
    else {
        const speed = VELOCITY.player * dt;
        if (keys['KeyA']) game.px -= speed; if (keys['KeyD']) game.px += speed;
        if (keys['KeyW']) game.py -= speed; if (keys['KeyS']) game.py += speed;
    }
    const rx = getRoadX(game.py, game.time);
    const rw = 80 + (game.py - ROAD_START_Y) * 2.5;
    game.px = Math.max(rx - rw/2, Math.min(rx + rw/2, game.px));
    game.py = Math.max(300, Math.min(580, game.py));

    if (game.obstacles.length === 0 && Math.random() < 0.1) { game.obstacles.push({ y: ROAD_START_Y, xRel: (Math.random()-0.5)*0.8, w: 200, h: 30 }); }
    game.obstacles.forEach((o, i) => {
        o.y += VELOCITY.obstacle * dt; const ox = getRoadX(o.y, game.time) + o.xRel * 1000;
        if (Math.abs(o.y - game.py) < 30 && Math.abs(ox - game.px) < 80) { game.freeze = 1.5; game.shake = 20; game.obstacles.splice(i, 1); }
        else if (o.y > 650) game.obstacles.splice(i, 1);
    });

    if (game.state === 'chase' && Math.random() < 0.02) {
        game.state = 'warning'; game.dmg = 1;
        if (currentStage === 1) { game.timer = 3.0; game.attackType = Math.random() > 0.5 ? 'left' : 'right'; }
        else if (currentStage === 2) { game.timer = 3.0; const r = Math.random(); game.attackType = r < 0.33 ? 'leftHalf' : (r < 0.66 ? 'bottom30' : 'top70'); }
        else if (currentStage === 3) { game.timer = 1.0; game.attackType = Math.random() > 0.5 ? 'leftHalf' : 'rightHalf'; }
        else if (currentStage === 4) {
            game.timer = 2.0; const r = Math.random();
            if (r < 0.25) game.attackType = 'bottom40'; else if (r < 0.5) { game.attackType = 'circle'; game.targetX = game.px; game.targetY = game.py; }
            else if (r < 0.75) game.attackType = 'top60'; else game.attackType = 'rightHalf';
        } else {
            const r = Math.random();
            if (r < 0.2) { game.attackType = 'bottom30'; game.timer = 1.0; game.dmg = 1; }
            else if (r < 0.4) { game.attackType = 'centerCircle'; game.timer = 2.0; game.dmg = 2; game.targetX = 480; game.targetY = 400; }
            else if (r < 0.6) { game.attackType = 'top60'; game.timer = 1.0; game.dmg = 1; }
            else if (r < 0.8) { game.attackType = 'leftHalf'; game.timer = 2.0; game.dmg = 2; }
            else { game.attackType = 'rightHalf'; game.timer = 2.0; game.dmg = 2; }
        }
    }
    if (game.state === 'warning') {
        game.timer -= dt;
        if (game.timer <= 0) {
            game.state = 'strike'; game.timer = 0.4;
            const curX = getRoadX(game.py, game.time); let hit = false;
            if (game.attackType === 'left' || game.attackType === 'leftHalf') hit = game.px < curX;
            else if (game.attackType === 'right' || game.attackType === 'rightHalf') hit = game.px > curX;
            else if (game.attackType === 'bottom30') hit = game.py > 480;
            else if (game.attackType === 'bottom40') hit = game.py > 420;
            else if (game.attackType === 'top70') hit = game.py < 480;
            else if (game.attackType === 'top60') hit = game.py < 420;
            else if (game.attackType === 'circle') hit = Math.sqrt((game.px-game.targetX)**2 + (game.py-game.targetY)**2) < 300;
            else if (game.attackType === 'centerCircle') hit = Math.sqrt((game.px-480)**2 + (game.py-400)**2) < 300;
            if (hit) { game.hp -= game.dmg; game.shake = 50; }
        }
    } else if (game.state === 'strike') { game.timer -= dt; if (game.timer <= 0) game.state = 'chase'; }
    
    document.getElementById('hp-fill').style.width = (game.hp/game.maxHp*100) + "%";
    document.getElementById('dist-fill').style.width = Math.min(100, (game.dist/game.goal*100)) + "%";
    
    if (game.dist >= game.goal) { 
        game.active = false; 
        if(currentStage < 5) startStory(currentStage + 1); 
        else startEnding(); 
    }
    if (game.hp <= 0) { 
        showGameOverWindow();
    }
}

function startEnding() {
    stopAllBGM(); document.getElementById('gameHUD').style.display = 'none';
    const e = document.getElementById('ending'); e.style.display = 'flex';
    setTimeout(() => e.style.opacity = 1, 50); renderEnding();
}
function renderEnding() {
    if(endIdx < endingLines.length) document.getElementById('ending-text').innerText = endingLines[endIdx] + "\n\n（クリックで次へ）";
    else showStaffRoll();
}
function proceedEnding() { endIdx++; renderEnding(); }

function showStaffRoll() {
    document.getElementById('ending-text').innerHTML = "<div style='animation: scroll 8s linear forwards;'>アイディア: 縫魔妖斗<br>他協力: AI<br><br>...Thank you for playing...</div>";
    setTimeout(() => location.reload(), 9000);
}

function draw() {
    if(!game.active) return;
    ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle="#010103"; ctx.fillRect(0,0,canvas.width,canvas.height);
    const sx = (Math.random()-0.5)*game.shake; ctx.setTransform(1,0,0,1,sx,sx); if(game.shake>0) game.shake*=0.8;
    const progress = game.dist / game.goal;

    if (currentStage === 1) {
        if (progress < 0.3) { ctx.fillStyle="#1a1005"; let lx=getRoadX(300,game.time)-400, rx=getRoadX(300,game.time)+400; ctx.fillRect(0,ROAD_START_Y,lx,600); ctx.fillRect(rx,ROAD_START_Y,960-rx,600); }
        else if (progress < 0.5) { ctx.fillStyle="#050510"; for(let i=0;i<8;i++) ctx.fillRect(((i*150+game.time*200)%1200)-100,100,100,300); }
        else if (progress < 0.8) { for(let i=0;i<5;i++){ let bx=(i*250+game.time*300)%1200-100; ctx.fillStyle="#222"; ctx.fillRect(bx,100,10,500); ctx.fillStyle="#ff0"; ctx.beginPath(); ctx.arc(bx+5,100,15,0,Math.PI*2); ctx.fill(); } }
        else { ctx.fillStyle="#020502"; for(let i=0;i<10;i++){ let bx=(i*120+game.time*400)%1200-100; ctx.beginPath(); ctx.moveTo(bx,600); ctx.lineTo(bx+40,150); ctx.lineTo(bx+80,600); ctx.fill(); } }
    } else if (currentStage === 2) {
        if (progress < 0.5) { for(let i=0; i<6; i++){ let bx=(i*200+game.time*350)%1200-100; ctx.fillStyle="#0a0a15"; ctx.fillRect(bx,150,80,200); ctx.fillStyle="#331"; ctx.fillRect(bx+20,180,10,10); } }
        else { ctx.fillStyle="#010401"; for(let i=0; i<12; i++){ let bx=(i*100+game.time*400)%1200-50; ctx.fillRect(bx,300,40,300); } }
    } else if (currentStage === 3) { 
        ctx.fillStyle="#0a0a0a"; for(let i=0; i<10; i++){ let bx=(i*150+game.time*600)%1500-100; ctx.fillStyle="#333"; ctx.fillRect(bx, 100, 20, 500); }
    } else if (currentStage === 4) { 
        ctx.fillStyle="#050505"; for(let i=0; i<4; i++) { let bx = (i*300+game.time*400)%1200-100; ctx.fillStyle="#111"; ctx.fillRect(bx, 100, 60, 500); ctx.fillStyle="#000"; ctx.fillRect(0, 100, 960, 60); }
    } else if (currentStage === 5) { 
        ctx.fillStyle="#080810"; for(let i=0; i<6; i++){ let bx=(i*200+game.time*100)%1200-100; ctx.fillStyle="#111"; ctx.fillRect(bx,200,80,400); ctx.fillStyle="#440"; ctx.fillRect(bx+20,300,15,15); }
    }

    ctx.fillStyle="#0d0d0d"; ctx.beginPath();
    for(let y=ROAD_START_Y;y<=600;y+=10){ let rx=getRoadX(y,game.time), rw=80+(y-ROAD_START_Y)*2.4; if(y===ROAD_START_Y)ctx.moveTo(rx-rw/2,y); else ctx.lineTo(rx-rw/2,y); }
    for(let y=600;y>=ROAD_START_Y;y-=10){ let rx=getRoadX(y,game.time), rw=80+(y-ROAD_START_Y)*2.4; ctx.lineTo(rx+rw/2,y); }
    ctx.fill(); ctx.strokeStyle="#800"; ctx.lineWidth=5; ctx.stroke();

    if (game.state === 'warning') {
        const flash = (game.time*20)%2<1; let rx=getRoadX(game.py,game.time);
        ctx.save();
        if(game.attackType === 'centerCircle') { ctx.beginPath(); ctx.arc(480, 400, 300, 0, Math.PI*2); ctx.clip(); }
        else { ctx.beginPath(); ctx.rect(0, ROAD_START_Y, 960, 600 - ROAD_START_Y); ctx.clip(); }
        ctx.fillStyle = flash ? "rgba(180,0,0,0.4)" : "rgba(100,0,0,0.1)";

        if (currentStage === 1) {
            if(game.attackType==='left'){ ctx.fillRect(0,ROAD_START_Y,rx,600); ctx.fillStyle="#fff"; ctx.font="bold 45px serif"; ctx.fillText("はい",rx-140,420); }
            else { ctx.fillRect(rx,ROAD_START_Y,960-rx,600); ctx.fillStyle="#fff"; ctx.font="bold 45px serif"; ctx.fillText("いいえ",rx+40,420); }
        } else if (currentStage === 2) {
            if(game.attackType==='leftHalf') ctx.fillRect(0,ROAD_START_Y,rx,600);
            else if(game.attackType==='bottom30') ctx.fillRect(0,480,960,120);
            else ctx.fillRect(0,ROAD_START_Y,960,360);
            ctx.fillStyle="#fff"; ctx.font="bold 50px serif"; ctx.fillText("ポポポポ...", 380, 300);
        } else if (currentStage === 3) {
            let areaX = (game.attackType==='leftHalf') ? 0 : rx; let areaW = (game.attackType==='leftHalf') ? rx : 960-rx;
            ctx.fillRect(areaX, ROAD_START_Y, areaW, 600);
            for(let i=0; i<15; i++) { ctx.strokeStyle="rgba(255,255,255,0.7)"; ctx.lineWidth=2; let zx = areaX + (Math.random()*areaW); ctx.beginPath(); ctx.moveTo(zx, ROAD_START_Y); ctx.lineTo(zx, 600); ctx.stroke(); }
        } else if (currentStage === 4) {
            if(game.attackType==='bottom40') ctx.fillRect(0,420,960,180);
            else if(game.attackType==='circle') { ctx.beginPath(); ctx.arc(game.targetX, game.targetY, 300, 0, Math.PI*2); ctx.fill(); }
            else if(game.attackType==='top60') ctx.fillRect(0,ROAD_START_Y,960,300);
            else ctx.fillRect(rx,ROAD_START_Y,960-rx,600);
            ctx.fillStyle="white"; ctx.font="bold 40px serif"; ctx.fillText("カサカサカサ...", 350, 280);
        } else if (currentStage === 5) {
            let areaX=0, areaW=960, areaY=ROAD_START_Y, areaH=600;
            if(game.attackType==='bottom30'){areaY=480; areaH=120;}
            else if(game.attackType==='top60'){areaH=360;}
            else if(game.attackType==='leftHalf'){areaW=rx;}
            else if(game.attackType==='rightHalf'){areaX=rx; areaW=960-rx;}
            if(game.attackType==='centerCircle'){ ctx.beginPath(); ctx.arc(480, 400, 300, 0, Math.PI*2); ctx.fill(); areaX=480-250; areaY=400-250; areaW=500; areaH=500; }
            else { ctx.fillRect(areaX, areaY, areaW, areaH); }
            ctx.strokeStyle="white"; ctx.lineWidth=8;
            ctx.beginPath(); ctx.moveTo(areaX+20, areaY+20); ctx.lineTo(areaX+areaW-20, areaY+areaH-20); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(areaX+areaW-20, areaY+20); ctx.lineTo(areaX+20, areaY+areaH-20); ctx.stroke();
            ctx.fillStyle="white"; ctx.font="bold 30px serif"; ctx.fillText("きれい...？", 410, 100);
        }
        ctx.restore();
    }

    game.obstacles.forEach(o => { let ox=getRoadX(o.y,game.time)+o.xRel*1000; ctx.fillStyle="#222"; ctx.fillRect(ox-o.w/2,o.y,o.w,o.h); });
    ctx.save(); ctx.translate(game.px,game.py); ctx.scale(1.8,1.8);
    let run = game.freeze>0?0:Math.sin(game.time*25);
    ctx.fillStyle="#ffdbac"; ctx.fillRect(-6,-55+run*2,12,12); ctx.fillStyle="#ffffff"; ctx.fillRect(-10,-43+run*2,20,25);
    ctx.fillStyle="#223366"; ctx.fillRect(-9,-18,8,20-run*10); ctx.fillRect(1,-18,8,20+run*10); ctx.restore();
    drawMirror();
}

function drawMirror() {
    mctx.fillStyle="#000"; mctx.fillRect(0,0,480,100);
    const gx=240, gy=50; const shakeX=(game.state==='warning')?(Math.random()-0.5)*15:0;
    mctx.save(); mctx.translate(gx+shakeX, gy); mctx.scale(1.5,1.5);
    if (currentStage === 1) { 
        mctx.fillStyle="#b87333"; mctx.beginPath(); mctx.arc(0,0,25,0,Math.PI*2); mctx.fill(); mctx.fillStyle="#000"; mctx.font="bold 20px serif"; mctx.fillText("十",-10,8); 
    } else if (currentStage === 2) {
        mctx.translate(0, 10); mctx.fillStyle="#fff"; mctx.beginPath(); mctx.moveTo(-25,50); mctx.lineTo(0,-35); mctx.lineTo(25,50); mctx.fill(); mctx.fillRect(-4,-45,8,20); mctx.beginPath(); mctx.arc(0,-48,12,0,Math.PI*2); mctx.fill(); mctx.beginPath(); mctx.ellipse(0,-58,35,10,0,0,Math.PI*2); mctx.fill(); mctx.fillStyle="black"; mctx.beginPath(); mctx.arc(-5,-48,2,0,Math.PI*2); mctx.arc(5,-48,2,0,Math.PI*2); mctx.fill();
    } else if (currentStage === 3) {
        mctx.fillStyle="#555"; mctx.beginPath(); mctx.arc(0,15,20,0,Math.PI*2); mctx.fill(); mctx.fillStyle="#fff"; mctx.beginPath(); mctx.moveTo(-20,15); mctx.lineTo(-40,-10); mctx.lineTo(-30,-10); mctx.fill();
    } else if (currentStage === 4) {
        mctx.fillStyle="#fff"; mctx.beginPath(); mctx.arc(0,10,15,0,Math.PI*2); mctx.fill(); mctx.strokeStyle="#fff"; mctx.lineWidth=4; mctx.beginPath(); mctx.moveTo(-15,10); mctx.lineTo(-30,40); mctx.moveTo(15,10); mctx.lineTo(30,40); mctx.stroke();
    } else if (currentStage === 5) {
        mctx.fillStyle="#fdd"; mctx.beginPath(); mctx.arc(0,10,18,0,Math.PI*2); mctx.fill(); mctx.fillStyle="#fff"; mctx.fillRect(-12,12,24,10); mctx.strokeStyle="#000"; mctx.strokeRect(-12,12,24,10);
    }
    mctx.restore();
}

const loop = (timestamp) => {
    if(!game.active) return;
    let dt=(timestamp-lastTime)/1000; if(dt>0.05)dt=0.016; lastTime=timestamp;
    update(dt); draw(); requestAnimationFrame(loop);
};
window.addEventListener("keydown",e=>keys[e.code] = true);
window.addEventListener("keyup",e=>keys[e.code] = false);
</script>
</body>
</html>