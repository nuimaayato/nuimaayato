<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MEMORY DRAW</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#07070b; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    #wrap { height: 100%; display:flex; align-items:center; justify-content:center; padding: 16px; }
    #game { width: min(980px, 98vw); aspect-ratio: 16/9; background: radial-gradient(1200px 600px at 50% 30%, #141724, #07070b); border:1px solid #2a2f3a; border-radius: 16px; position: relative; overflow:hidden; box-shadow: 0 12px 48px rgba(0,0,0,.55); }
    canvas { width:100%; height:100%; display:block; }

    .hud { position:absolute; inset:0; pointer-events:none; }

    .topbar { position:absolute; top:12px; left:12px; right:12px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .pill { background: rgba(10,12,18,.72); border:1px solid rgba(255,255,255,.10); padding:8px 10px; border-radius: 999px; font-size: 14px; display:flex; gap:10px; align-items:center; backdrop-filter: blur(6px); }
    .pill b { font-weight: 800; letter-spacing:.02em; }
    .bar { width: 260px; height: 10px; border-radius: 999px; background: rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.10); }
    .bar > div { height:100%; width: 0%; background: rgba(255,255,255,.88); }

    /* ===== Center Panel (readability rework) ===== */
    .centerWrap { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(780px, 92%); pointer-events:none; }
    .centerCard{
      pointer-events:auto;
      text-align:center;
      padding: 22px 22px 18px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(8,10,16,.86), rgba(8,10,16,.72));
      box-shadow: 0 14px 70px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }
    .centerCard::before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 220px at 50% 0%, rgba(255,255,255,.10), transparent 60%);
      pointer-events:none;
      opacity:.55;
    }
    .centerCard > * { position:relative; }

    .titleBig{
      margin:0;
      font-size: clamp(30px, 4.6vw, 56px);
      letter-spacing:.12em;
      font-weight: 900;
      text-transform: uppercase;
    }

    .subLead{
      margin: 12px 0 0;
      font-size: clamp(14px, 1.8vw, 18px);
      line-height: 1.85;
      opacity: .92;
    }
    .subLead b{ font-weight:900; }

    .rulesGrid{
      margin: 14px auto 0;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      width:min(640px, 100%);
      text-align:left;
    }
    @media (max-width: 520px){
      .rulesGrid{ grid-template-columns: 1fr; }
    }
    .ruleBox{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.65;
      opacity: .92;
    }
    .ruleBox .k{
      font-weight: 900;
      letter-spacing:.02em;
      opacity:.95;
      display:block;
      margin-bottom:2px;
    }

    .btnRow { display:flex; gap:10px; justify-content:center; margin-top: 16px; flex-wrap:wrap; pointer-events:auto; }
    button { cursor:pointer; border-radius: 12px; padding:10px 14px; border:1px solid rgba(255,255,255,.16); background: rgba(255,255,255,.06); color:#fff; font-weight:900; letter-spacing:.02em; }
    button:hover { background: rgba(255,255,255,.10); }

    .hintLine{
      margin-top: 10px;
      font-size: 13px;
      opacity: .72;
      line-height: 1.6;
    }

    .bottomHelp { position:absolute; left:12px; right:12px; bottom:12px; display:flex; justify-content:space-between; gap:10px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:2px 6px; border:1px solid rgba(255,255,255,.18); border-bottom-width:2px; border-radius:6px; background: rgba(255,255,255,.06); }
    .muted { opacity:.7; }

    .toast { position:absolute; left:50%; bottom:84px; transform:translateX(-50%); padding:10px 14px; border-radius: 999px; background: rgba(0,0,0,.60); border:1px solid rgba(255,255,255,.14); font-size: 14px; opacity:0; transition: opacity .18s ease; }
    .toast.show { opacity:1; }
    .flash { position:absolute; inset:0; background:#fff; opacity:0; pointer-events:none; mix-blend-mode: screen; }

    .shake { animation: shake .22s linear; }
    @keyframes shake { 0%{transform:translate(0,0)} 25%{transform:translate(6px,0)} 50%{transform:translate(-6px,0)} 75%{transform:translate(4px,0)} 100%{transform:translate(0,0)} }
  </style>
</head>
<body>
<div id="wrap">
  <div id="game">
    <canvas id="cv" width="1280" height="720"></canvas>

    <div class="hud">
      <div class="topbar">
        <div class="pill"><b id="stageTxt">STAGE -</b><span id="phaseTxt" class="muted">-</span></div>
        <div class="pill">
          <span>TIME</span>
          <div class="bar"><div id="timeFill"></div></div>
          <span id="timeTxt" style="min-width:72px; text-align:right;">--.--s</span>
        </div>
        <div class="pill"><span>SCORE</span><b id="scoreTxt">0</b><span class="muted">BEST</span><b id="bestTxt">0</b></div>
      </div>

      <!-- Center UI -->
      <div class="centerWrap" id="centerWrap" style="display:none;">
        <div class="centerCard">
          <h1 class="titleBig" id="centerTitle">MEMORY DRAW</h1>
          <div class="subLead" id="centerLead">-</div>

          <div class="rulesGrid" id="rulesGrid" style="display:none;">
            <div class="ruleBox">
              <span class="k">操作</span>
              <span><span class="kbd">V</span> 左 ／ <span class="kbd">B</span> 真ん中 ／ <span class="kbd">N</span> 右</span>
            </div>
            <div class="ruleBox">
              <span class="k">流れ</span>
              <span>記憶5秒 → 待機2秒 → 制限10秒</span>
            </div>
            <div class="ruleBox">
              <span class="k">ルール</span>
              <span>3人の中から<strong>犯人だけ</strong>を撃つ</span>
            </div>
            <div class="ruleBox">
              <span class="k">スコア</span>
              <span>反応が速いほど加点／ミスは減点</span>
            </div>
          </div>

          <div class="btnRow" id="btnRow" style="display:none;">
            <button id="okBtn">OK</button>
            <button id="startBtn">START</button>
            <button id="toggleBgmBtn">BGM: ON</button>
            <button id="toggleSeBtn">SE: ON</button>
          </div>

          <div class="hintLine" id="centerHint">-</div>
        </div>
      </div>

      <div class="bottomHelp">
        <div class="pill">操作：<span class="kbd">V</span> 左 ／ <span class="kbd">B</span> 真ん中 ／ <span class="kbd">N</span> 右 ／ <span class="kbd">Enter</span> 決定 ／ <span class="kbd">Esc</span> 戻る</div>
        <div class="pill muted">※ベストスコアは端末内保存</div>
      </div>

      <div class="toast" id="toast"></div>
      <div class="flash" id="flash"></div>
    </div>
  </div>
</div>

<script>
(() => {
  // =======================
  //   CONFIG
  // =======================
  const TITLE_BGM_SRC = "Untitled.mp3"; // ← タイトル音源（HTMLと同じフォルダ）

  // =======================
  //   Utils
  // =======================
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const fmt = (n) => (n|0).toLocaleString("ja-JP");
  const pick = (arr) => arr[(Math.random()*arr.length)|0];
  const choiceIndex = (n) => (Math.random()*n)|0;

  // =======================
  //   DOM
  // =======================
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const stageTxt = document.getElementById("stageTxt");
  const phaseTxt = document.getElementById("phaseTxt");
  const timeTxt = document.getElementById("timeTxt");
  const timeFill = document.getElementById("timeFill");
  const scoreTxt = document.getElementById("scoreTxt");
  const bestTxt = document.getElementById("bestTxt");

  const centerWrap = document.getElementById("centerWrap");
  const centerTitle = document.getElementById("centerTitle");
  const centerLead = document.getElementById("centerLead");
  const centerHint = document.getElementById("centerHint");
  const rulesGrid = document.getElementById("rulesGrid");

  const btnRow = document.getElementById("btnRow");
  const okBtn = document.getElementById("okBtn");
  const startBtn = document.getElementById("startBtn");
  const toggleBgmBtn = document.getElementById("toggleBgmBtn");
  const toggleSeBtn = document.getElementById("toggleSeBtn");

  const toast = document.getElementById("toast");
  const flash = document.getElementById("flash");
  const gameBox = document.getElementById("game");

  // =======================
  //   Title BGM (HTMLAudio)
  // =======================
  let bgmEnabled = true;
  const titleBgm = new Audio(TITLE_BGM_SRC);
  titleBgm.loop = true;
  titleBgm.volume = 0.7;

  async function tryPlayTitleBgm() {
    if (!bgmEnabled) return;
    try { await titleBgm.play(); } catch (_) { /* autoplay blocked until gesture */ }
  }
  function stopTitleBgm() {
    try { titleBgm.pause(); titleBgm.currentTime = 0; } catch(_) {}
  }

  // =======================
  //   SE (WebAudio)
  // =======================
  let audioCtx = null;
  let seEnabled = true;
  function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  function beep({freq=440, dur=0.08, type="sine", gain=0.06, when=0} = {}) {
    if (!seEnabled) return;
    ensureAudio();
    const t0 = audioCtx.currentTime + when;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0.0001;
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.stop(t0 + dur + 0.02);
  }
  function noisePop(dur=0.12, gain=0.05) {
    if (!seEnabled) return;
    ensureAudio();
    const bufferSize = Math.max(1, (audioCtx.sampleRate * dur)|0);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    g.gain.value = gain;
    src.buffer = buffer;
    src.connect(g).connect(audioCtx.destination);
    src.start();
  }
  function gunshot() { noisePop(0.085, 0.085); beep({freq:120, dur:0.06, type:"square", gain:0.06}); }
  function successChime(){ beep({freq:880, dur:0.06, gain:0.05}); beep({freq:1108, dur:0.08, gain:0.05, when:0.05}); }
  function failBuzz(){ beep({freq:160, dur:0.12, type:"sawtooth", gain:0.05}); beep({freq:120, dur:0.12, type:"sawtooth", gain:0.05, when:0.03}); }
  function heartbeat(){ beep({freq:70, dur:0.06, gain:0.06}); beep({freq:55, dur:0.07, gain:0.05, when:0.08}); }

  // =======================
  //   Visual FX
  // =======================
  let flashAlpha = 0;
  function doFlash(amount=0.55) { flashAlpha = Math.max(flashAlpha, amount); }
  function doShake() { gameBox.classList.remove("shake"); void gameBox.offsetWidth; gameBox.classList.add("shake"); }
  function showToast(text, ms=900) {
    toast.textContent = text;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), ms);
  }

  // =======================
  //   Design dictionary (Japanese names)
  // =======================
  const JP = {
    hat: {
      black:"黒テンガロン", white:"白テンガロン", torn:"つば破れ帽", redRibbon:"赤リボン帽", metalRim:"金属縁ハット",
      hood:"フード", goggles:"ゴーグル帽", woven:"編み笠", horn:"角飾り", none:"帽子なし"
    },
    coat: {
      blackLong:"黒ロングコート", brownDuster:"茶ダスター", redPoncho:"赤ポンチョ", military:"軍服ジャケット", desertCape:"砂漠マント",
      leatherVest:"レザーベスト", blueTrench:"青トレンチ", ragCoat:"ボロ布コート", metalShoulder:"金属肩当て", robe:"ローブ"
    },
    bandana: {
      red:"赤バンダナ", black:"黒バンダナ", white:"白バンダナ", camo:"迷彩バンダナ", skull:"ドクロ柄", stripe:"縦縞",
      sand:"砂色", purple:"紫", gold:"金刺繍", none:"なし"
    },
    scar: {
      eyeR:"右目の縦傷", cheekL:"左頬の斜め傷", mouth:"口元の裂傷", nose:"鼻横の傷", brow:"眉の傷", foreheadX:"額の×傷",
      burn:"火傷跡", stitch:"縫合跡", dots:"点傷", none:"傷なし"
    },
    gun: {
      long:"長銃身", short:"短銃身", dual:"二丁拳銃", antique:"古式モデル", gold:"金メッキ", matte:"黒マット",
      engrave:"彫刻入り", scope:"スコープ", silencer:"サイレンサー", boxy:"角型"
    }
  };

  const HATS = Object.keys(JP.hat);
  const COATS = Object.keys(JP.coat);
  const BANDANAS = Object.keys(JP.bandana);
  const SCARS = Object.keys(JP.scar);
  const GUNS = Object.keys(JP.gun);
  const FEATURE_KEYS = ["hat","coat","bandana","scar","gun"];

  const PRESETS = [
    { id:"TYPE01", hat:"black",    coat:"blackLong",     bandana:"black",  scar:"eyeR",       gun:"long" },
    { id:"TYPE02", hat:"white",    coat:"redPoncho",     bandana:"white",  scar:"nose",       gun:"short" },
    { id:"TYPE03", hat:"none",     coat:"military",      bandana:"none",   scar:"foreheadX",  gun:"gold" },
    { id:"TYPE04", hat:"goggles",  coat:"desertCape",    bandana:"sand",   scar:"stitch",     gun:"scope" },
    { id:"TYPE05", hat:"torn",     coat:"ragCoat",       bandana:"skull",  scar:"burn",       gun:"antique" },
    { id:"TYPE06", hat:"redRibbon",coat:"leatherVest",   bandana:"red",    scar:"brow",       gun:"dual" },
    { id:"TYPE07", hat:"metalRim", coat:"metalShoulder", bandana:"black",  scar:"dots",       gun:"boxy" },
    { id:"TYPE08", hat:"woven",    coat:"brownDuster",   bandana:"none",   scar:"none",       gun:"short" },
    { id:"TYPE09", hat:"black",    coat:"blueTrench",    bandana:"black",  scar:"cheekL",     gun:"engrave" },
    { id:"TYPE10", hat:"hood",     coat:"robe",          bandana:"purple", scar:"mouth",      gun:"silencer" }
  ];

  // ====== Hardcore correctness: unique visual signatures ======
  function signature(d) { return `${d.hat}|${d.coat}|${d.bandana}|${d.scar}|${d.gun}`; }

  function makeDecoy(from, stageNum) {
    const d = structuredClone(from);
    d.id = "DECOY_" + Math.random().toString(16).slice(2);
    const keepCount = (stageNum <= 2) ? 2 : 3;

    const keys = [...FEATURE_KEYS];
    const keep = [];
    while (keep.length < keepCount) keep.push(keys.splice((Math.random()*keys.length)|0,1)[0]);

    for (const k of FEATURE_KEYS) {
      if (keep.includes(k)) continue;
      const pool = (k==="hat")?HATS : (k==="coat")?COATS : (k==="bandana")?BANDANAS : (k==="scar")?SCARS : GUNS;
      let v = pick(pool);
      while (v === from[k]) v = pick(pool);
      d[k] = v;
    }
    return d;
  }

  function makeMob(excludeSigs) {
    for (let tries=0; tries<200; tries++) {
      const d = {
        id: "MOB_" + Math.random().toString(16).slice(2),
        hat: pick(HATS), coat: pick(COATS), bandana: pick(BANDANAS), scar: pick(SCARS), gun: pick(GUNS)
      };
      const sig = signature(d);
      if (!excludeSigs.has(sig)) return d;
    }
    return { id:"MOB_FALLBACK", hat:"horn", coat:"ragCoat", bandana:"camo", scar:"dots", gun:"matte" };
  }

  function generateStage(stageNum, lastPresetIndex) {
    let idx = choiceIndex(PRESETS.length);
    if (idx === lastPresetIndex) idx = (idx + 1 + choiceIndex(PRESETS.length-1)) % PRESETS.length;

    const criminal = structuredClone(PRESETS[idx]);

    const shownCount = stageNum <= 2 ? 3 : (stageNum === 3 ? 3 : 4);
    const keys = [...FEATURE_KEYS];
    const shownKeys = [];
    while (shownKeys.length < shownCount) shownKeys.push(keys.splice((Math.random()*keys.length)|0,1)[0]);

    let decoy = makeDecoy(criminal, stageNum);
    const sigC = signature(criminal);
    for (let tries=0; tries<100 && signature(decoy) === sigC; tries++) decoy = makeDecoy(criminal, stageNum);

    const exclude = new Set([sigC, signature(decoy)]);
    const mob = makeMob(exclude);

    const lineup = [
      { ...criminal, isCriminal: true },
      { ...decoy, isCriminal: false },
      { ...mob, isCriminal: false }
    ];

    for (let i=lineup.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [lineup[i], lineup[j]] = [lineup[j], lineup[i]];
    }
    const correctPos = lineup.findIndex(p => p.isCriminal === true);

    const sigs = new Set(lineup.map(signature));
    if (sigs.size !== 3 || correctPos < 0) return generateStage(stageNum, lastPresetIndex);

    return { presetIndex: idx, criminal, shownKeys, lineup, correctPos };
  }

  // =======================
  //   Drawing
  // =======================
  function drawBackground(t) {
    const w=cv.width, h=cv.height;

    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#0b0c14");
    g.addColorStop(0.55, "#07070b");
    g.addColorStop(1, "#050509");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // town silhouettes
    ctx.fillStyle = "rgba(255,255,255,0.04)";
    for (let i=0;i<12;i++){
      const bw = 70 + (i%3)*40;
      const bh = 90 + (i%4)*50;
      const x = (i/12)*w + (Math.sin(t*0.0006+i)*10);
      const y = h*0.40 + (i%2)*14;
      ctx.fillRect(x, y, bw, bh);
    }

    // fog bands
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    for (let i=0;i<7;i++){
      const y = h*0.34 + i*22 + Math.sin(t*0.001+i)*6;
      ctx.fillRect(0,y,w,7);
    }

    // ground
    const gg = ctx.createLinearGradient(0,h*0.70,0,h);
    gg.addColorStop(0,"rgba(255,255,255,0.05)");
    gg.addColorStop(1,"rgba(255,255,255,0.02)");
    ctx.fillStyle = gg;
    ctx.fillRect(0,h*0.70,w,h*0.30);

    // vignette
    const vg = ctx.createRadialGradient(w/2,h/2, 160, w/2,h/2, 980);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.78)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
  }

  function getHatColor(k){ return ({
    black:"#1b1d24", white:"#d6d8de", torn:"#3a2a21", redRibbon:"#2a2328", metalRim:"#22262e",
    hood:"#101218", goggles:"#20252e", woven:"#3a3326", horn:"#16171c", none:null
  })[k] ?? "#222";}

  function getCoatColor(k){ return ({
    blackLong:"#1a1e26", brownDuster:"#3b2b22", redPoncho:"#4a1d24", military:"#27312f", desertCape:"#3a3328",
    leatherVest:"#3a2422", blueTrench:"#1f2d46", ragCoat:"#2a2a2a", metalShoulder:"#222830", robe:"#181626"
  })[k] ?? "#222";}

  function getBandanaColor(k){ return ({
    red:"#7a2129", black:"#0f1115", white:"#dcdde2", camo:"#2b3a2b", skull:"#111318",
    stripe:"#2c2f36", sand:"#5a4c3a", purple:"#3b1f4a", gold:"#6b5a1f", none:null
  })[k] ?? "#222";}

  function gunTint(k){ return (k==="gold") ? "#6a5a1b" : "#2a2f37"; }

  function drawScar(cx, cy, scar) {
    if (!scar || scar === "none") return;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.lineCap="round";
    ctx.lineWidth=3;

    const line = (x1,y1,x2,y2, col="rgba(210,90,90,0.85)") => { ctx.strokeStyle=col; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); };

    switch(scar){
      case "eyeR": line(14,-6, 22,10); break;
      case "cheekL": line(-18,4, -6,14); break;
      case "mouth": line(-10,14, 12,10); break;
      case "nose": line(0,-2, 0,14); break;
      case "brow": line(-12,-12, 2,-6); break;
      case "foreheadX": line(-8,-18, 8,-2); line(8,-18,-8,-2); break;
      case "burn":
        ctx.strokeStyle="rgba(180,80,40,0.75)";
        ctx.beginPath(); ctx.arc(-10,4,10,0,Math.PI*1.6); ctx.stroke();
        break;
      case "stitch":
        line(16,-10,16,12,"rgba(200,200,220,0.75)");
        for(let i=-8;i<=10;i+=6) line(12,i,20,i+2,"rgba(200,200,220,0.75)");
        break;
      case "dots":
        ctx.fillStyle="rgba(200,80,80,0.75)";
        for(let i=0;i<4;i++){ ctx.beginPath(); ctx.arc(-14+i*7, 10+i*2, 2.2, 0, Math.PI*2); ctx.fill(); }
        break;
    }
    ctx.restore();
  }

  function drawPerson(x, baseY, d, opts={}) {
    const {alpha=1, highlight=false} = opts;
    ctx.save();
    ctx.globalAlpha = alpha;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.38)";
    ctx.beginPath();
    ctx.ellipse(x, baseY+18, 112, 18, 0, 0, Math.PI*2);
    ctx.fill();

    const headY = baseY - 280;
    const torsoY = baseY - 240;

    if (highlight) {
      ctx.strokeStyle = "rgba(255,255,255,0.30)";
      ctx.lineWidth = 6;
      ctx.beginPath(); ctx.roundRect(x-160, baseY-330, 320, 380, 26); ctx.stroke();
    }

    // coat
    const coatC = getCoatColor(d.coat);
    const coatG = ctx.createLinearGradient(x, torsoY, x, baseY);
    coatG.addColorStop(0, coatC);
    coatG.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = coatG;
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(x-75, torsoY, 150, 260, 26); ctx.fill(); ctx.stroke();

    // folds
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 2;
    for (let i=-2;i<=2;i++){
      ctx.beginPath();
      ctx.moveTo(x + i*16, torsoY+40);
      ctx.lineTo(x + i*22, baseY-10);
      ctx.stroke();
    }

    // head
    const skinG = ctx.createRadialGradient(x-12, headY+28, 12, x, headY+40, 70);
    skinG.addColorStop(0,"rgba(230,230,240,0.18)");
    skinG.addColorStop(1,"rgba(40,40,55,0.10)");
    ctx.fillStyle = skinG;
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, headY+46, 35, 46, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // bandana
    const bc = getBandanaColor(d.bandana);
    if (bc) {
      ctx.fillStyle = bc;
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.roundRect(x-44, headY+54, 88, 22, 12); ctx.fill(); ctx.stroke();
    }

    // scar
    drawScar(x, headY+46, d.scar);

    // hat
    if (d.hat && d.hat !== "none") {
      ctx.save();
      ctx.translate(x, headY+16);
      const hc = getHatColor(d.hat);
      ctx.fillStyle = hc;
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 2;

      if (d.hat === "hood") {
        ctx.beginPath();
        ctx.moveTo(-66, 28);
        ctx.quadraticCurveTo(-74, -16, -38, -38);
        ctx.quadraticCurveTo(0, -58, 38, -38);
        ctx.quadraticCurveTo(74, -16, 66, 28);
        ctx.closePath();
        ctx.fill(); ctx.stroke();
      } else {
        ctx.beginPath(); ctx.roundRect(-58, 18, 116, 16, 10); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.roundRect(-36, -26, 72, 52, 14); ctx.fill(); ctx.stroke();

        if (d.hat === "redRibbon") { ctx.fillStyle="#7a2129"; ctx.fillRect(-36, 0, 72, 8); }
        if (d.hat === "goggles") {
          ctx.fillStyle="rgba(220,220,240,0.16)";
          ctx.beginPath(); ctx.roundRect(-24, -12, 48, 14, 7); ctx.fill();
        }
        if (d.hat === "metalRim") {
          ctx.strokeStyle="rgba(200,200,220,0.30)";
          ctx.beginPath(); ctx.roundRect(-58, 18, 116, 16, 10); ctx.stroke();
        }
        if (d.hat === "horn") {
          ctx.fillStyle="#16171c";
          ctx.beginPath(); ctx.moveTo(-38,-18); ctx.quadraticCurveTo(-62,-40,-46,-8); ctx.fill();
          ctx.beginPath(); ctx.moveTo(38,-18); ctx.quadraticCurveTo(62,-40,46,-8); ctx.fill();
        }
      }
      ctx.restore();
    }

    // arms
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath(); ctx.roundRect(x-96, torsoY+140, 60, 22, 12); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x+36, torsoY+140, 60, 22, 12); ctx.fill();

    // gun
    ctx.save();
    ctx.translate(x+10, torsoY+182);
    ctx.fillStyle = gunTint(d.gun);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth=2;
    const len = (d.gun==="long"||d.gun==="scope") ? 76 : (d.gun==="short" ? 50 : 60);

    ctx.beginPath(); ctx.roundRect(-len/2, -6, len, 12, 7); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.roundRect(-9, 8, 18, 22, 7); ctx.fill(); ctx.stroke();

    if (d.gun==="dual") {
      ctx.save();
      ctx.translate(34, 0);
      ctx.beginPath(); ctx.roundRect(-25, -6, 50, 12, 7); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.roundRect(-9, 8, 18, 22, 7); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    if (d.gun==="scope") { ctx.fillStyle="rgba(255,255,255,0.15)"; ctx.beginPath(); ctx.roundRect(-18,-18,36,8,6); ctx.fill(); }
    if (d.gun==="silencer") { ctx.fillStyle="rgba(255,255,255,0.10)"; ctx.beginPath(); ctx.roundRect(len/2-6,-8,28,16,9); ctx.fill(); }
    if (d.gun==="engrave") { ctx.strokeStyle="rgba(255,255,255,0.22)"; ctx.beginPath(); ctx.moveTo(-len/2+8,0); ctx.lineTo(len/2-10,0); ctx.stroke(); }
    if (d.gun==="boxy") { ctx.fillStyle="rgba(255,255,255,0.12)"; ctx.fillRect(-len/2+6,-14,18,16); }
    if (d.gun==="antique") { ctx.fillStyle="#3b2b22"; ctx.fillRect(-6,8,12,22); }
    ctx.restore();

    ctx.restore();
  }

  function drawMemoryCard(design, shownKeys) {
    const w=cv.width, h=cv.height;

    ctx.save();
    ctx.fillStyle = "rgba(8,10,16,0.78)";
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 2;
    const pw=840, ph=470;
    const x = (w-pw)/2, y=(h-ph)/2;
    ctx.beginPath(); ctx.roundRect(x,y,pw,ph,22); ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.94)";
    ctx.font = "900 34px system-ui, sans-serif";
    ctx.fillText("覚えろ。", x+32, y+56);

    const label = { hat:"帽子", coat:"上着", bandana:"バンダナ", scar:"傷", gun:"銃" };
    ctx.font = "700 18px system-ui, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    let yy = y+98;
    for (const k of shownKeys) {
      const nice = JP[k][design[k]] ?? String(design[k]);
      ctx.fillText(`・${label[k]}：${nice}`, x+32, yy);
      yy += 30;
    }
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "600 14px system-ui, sans-serif";
    ctx.fillText("※表示された特徴だけで判断（他はフェイク要素）", x+32, y+ph-26);

    drawPerson(x+pw*0.72, y+ph*0.86, design, {alpha:0.95});
    ctx.restore();
  }

  // =======================
  //   UI helpers
  // =======================
  function showCenter(show) { centerWrap.style.display = show ? "block" : "none"; }
  function setCenterUI({title, lead, hint, showRules, mode}) {
    centerTitle.textContent = title ?? "MEMORY DRAW";
    centerLead.innerHTML = lead ?? "";
    centerHint.innerHTML = hint ?? "";
    rulesGrid.style.display = showRules ? "grid" : "none";
    btnRow.style.display = "flex";

    // mode: "INTRO" | "TITLE" | "FINISH"
    if (mode === "INTRO") {
      okBtn.style.display = "inline-block";
      startBtn.style.display = "none";
      toggleBgmBtn.style.display = "none";
      toggleSeBtn.style.display = "none";
    } else if (mode === "TITLE") {
      okBtn.style.display = "none";
      startBtn.style.display = "inline-block";
      toggleBgmBtn.style.display = "inline-block";
      toggleSeBtn.style.display = "inline-block";
    } else if (mode === "FINISH") {
      okBtn.style.display = "none";
      startBtn.style.display = "inline-block";
      toggleBgmBtn.style.display = "none";
      toggleSeBtn.style.display = "none";
    }
  }

  function refreshButtons() {
    toggleBgmBtn.textContent = `BGM: ${bgmEnabled ? "ON" : "OFF"}`;
    toggleSeBtn.textContent  = `SE: ${seEnabled ? "ON" : "OFF"}`;
  }

  // =======================
  //   Game State
  // =======================
  const PHASE = { INTRO:"INTRO", TITLE:"TITLE", MEMORY:"MEMORY", WAIT:"WAIT", PLAY:"PLAY", RESULT:"RESULT", FINISH:"FINISH" };

  let state = {
    phase: PHASE.INTRO,
    stage: 0,
    totalStages: 5,
    score: 0,
    best: 0,

    stageData: null,
    lastPresetIndex: -1,

    phaseStart: 0,
    memoryMs: 5000,
    waitMs: 2000,
    playMs: 10000,
    resultMs: 1200,

    spawnTime: 0,
    answered: false,
    pickedPos: -1,
    correctPos: -1,
    answerAt: 0,

    combo: 0,
    comboMul: 1.0,
    lastResult: null
  };

  function loadBest() {
    const v = Number(localStorage.getItem("md_best") || "0");
    state.best = isFinite(v) ? v : 0;
    bestTxt.textContent = fmt(state.best);
  }
  function saveBest() {
    if (state.score > state.best) {
      state.best = state.score;
      localStorage.setItem("md_best", String(state.best));
    }
    bestTxt.textContent = fmt(state.best);
  }

  function updateHud() {
    stageTxt.textContent = (state.phase===PHASE.INTRO || state.phase===PHASE.TITLE) ? "STAGE -" : `STAGE ${state.stage}/${state.totalStages}`;
    phaseTxt.textContent = ({INTRO:"INTRO",TITLE:"TITLE",MEMORY:"MEMORY",WAIT:"WAIT",PLAY:"DRAW",RESULT:"RESULT",FINISH:"FINISH"})[state.phase] || "-";
    scoreTxt.textContent = fmt(state.score);
  }

  function enterIntro() {
    stopTitleBgm(); // ✅ タイトル前は鳴らさない
    state.phase = PHASE.INTRO;
    state.phaseStart = now();
    showCenter(true);
    setCenterUI({
      title: "早撃ちしますか？",
      lead:
        "このミニゲームは <b>記憶</b> と <b>反射神経</b> の合成です。<br>" +
        "準備ができたら <b>Enter</b> か <b>クリック</b> で進んでね。",
      hint: "Enter / クリック：進む　｜　Esc：何もしない（この画面のまま）",
      showRules: false,
      mode: "INTRO"
    });
    updateHud();
  }

  function enterTitle() {
    state.phase = PHASE.TITLE;
    state.phaseStart = now();
    showCenter(true);
    setCenterUI({
      title: "MEMORY DRAW",
      lead:
        "犯人のデザインを覚えて、<b>3人の中から撃ち抜け。</b>",
      hint:
        "Space / Enter：開始　｜　V・B・N：選択（ゲーム中）　｜　Esc：戻る",
      showRules: true,
      mode: "TITLE"
    });
    refreshButtons();
    updateHud();
    tryPlayTitleBgm(); // ✅ タイトルに入ってから鳴る
  }

  function resetRun() {
    state.stage = 0;
    state.score = 0;
    state.combo = 0;
    state.comboMul = 1.0;
    state.lastPresetIndex = -1;
    updateHud();
  }

  function startGame() {
    ensureAudio();
    stopTitleBgm(); // タイトル音源はゲーム開始で止める
    resetRun();
    nextStage();
  }

  function nextStage() {
    state.stage++;
    if (state.stage > state.totalStages) { enterFinish(); return; }

    state.stageData = generateStage(state.stage, state.lastPresetIndex);
    state.lastPresetIndex = state.stageData.presetIndex;
    state.correctPos = state.stageData.correctPos;

    state.answered = false;
    state.pickedPos = -1;
    state.lastResult = null;

    state.phase = PHASE.MEMORY;
    state.phaseStart = now();
    showCenter(false);
    updateHud();
    heartbeat();
  }

  function enterWait() {
    state.phase = PHASE.WAIT;
    state.phaseStart = now();
    heartbeat(); setTimeout(()=>heartbeat(), 260);
  }
  function enterPlay() {
    state.phase = PHASE.PLAY;
    state.phaseStart = now();
    state.spawnTime = now();
    updateHud();
  }
  function enterResult() {
    state.phase = PHASE.RESULT;
    state.phaseStart = now();
    updateHud();
  }
  function enterFinish() {
    state.phase = PHASE.FINISH;
    state.phaseStart = now();
    saveBest();
    showCenter(true);
    setCenterUI({
      title: "FINISH",
      lead: `合計スコア：<b>${fmt(state.score)}</b>`,
      hint: "Enter / Space：もう一度　｜　Esc：タイトルへ",
      showRules: false,
      mode: "FINISH"
    });
    updateHud();
  }

  function applyScore(correct, deltaMs) {
    const t = deltaMs / 1000;
    if (correct) {
      const base = 1000;
      const bonus = Math.max(0, 1200 - t * 600);
      state.combo++;
      state.comboMul = (state.combo>=4) ? 2.0 : (state.combo>=3) ? 1.5 : (state.combo>=2) ? 1.2 : 1.0;
      const add = Math.round((base + bonus) * state.comboMul);
      state.score += add;
      state.lastResult = "OK";
      successChime();
      doFlash(0.35);
      showToast(`+${fmt(add)}（${t.toFixed(3)}s ×${state.comboMul.toFixed(1)}）`, 1100);
    } else {
      const pen = 600;
      state.score = Math.max(0, state.score - pen);
      state.combo = 0;
      state.comboMul = 1.0;
      state.lastResult = "NG";
      failBuzz();
      doShake();
      showToast(`-${fmt(pen)}（ミス）`, 900);
    }
  }

  function handlePick(pos) {
    if (state.phase !== PHASE.PLAY || state.answered) return;
    state.answered = true;
    state.pickedPos = pos;
    state.answerAt = now();

    gunshot(); doFlash(0.52);

    const delta = state.answerAt - state.spawnTime;
    const correct = (pos === state.correctPos); // ✅ 正確判定（確定位置のみ参照）
    applyScore(correct, delta);
    enterResult();
  }

  function timeOut() {
    if (state.phase !== PHASE.PLAY || state.answered) return;
    state.answered = true;
    state.lastResult = "TIME";
    state.combo = 0; state.comboMul = 1.0;
    failBuzz();
    showToast("時間切れ", 900);
    enterResult();
  }

  // =======================
  //   Input
  // =======================
  function onConfirm() {
    if (state.phase === PHASE.INTRO) enterTitle();
    else if (state.phase === PHASE.TITLE) startGame();
    else if (state.phase === PHASE.FINISH) startGame();
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (k === "escape") {
      if (state.phase === PHASE.TITLE || state.phase === PHASE.FINISH) {
        enterTitle(); // タイトルへ戻る
      }
      return;
    }

    if (k === "enter" || k === " ") {
      onConfirm();
      return;
    }

    if (k === "v") handlePick(0);
    if (k === "b") handlePick(1);
    if (k === "n") handlePick(2);
  });

  // Buttons
  okBtn.addEventListener("click", () => onConfirm());
  startBtn.addEventListener("click", () => startGame());

  toggleBgmBtn.addEventListener("click", async () => {
    bgmEnabled = !bgmEnabled;
    refreshButtons();
    showToast(`BGM ${bgmEnabled ? "ON" : "OFF"}`, 700);
    if (bgmEnabled && state.phase === PHASE.TITLE) await tryPlayTitleBgm();
    else stopTitleBgm();
  });

  toggleSeBtn.addEventListener("click", () => {
    seEnabled = !seEnabled;
    refreshButtons();
    showToast(`SE ${seEnabled ? "ON" : "OFF"}`, 700);
    if (seEnabled) { ensureAudio(); beep({freq:660, dur:0.06, gain:0.05}); }
  });

  // Resume audio on pointer for mobile + allow title BGM after gesture
  window.addEventListener("pointerdown", async () => {
    if (audioCtx && audioCtx.state==="suspended") await audioCtx.resume();
    if (state.phase === PHASE.TITLE) await tryPlayTitleBgm();
  });

  // =======================
  //   Loop
  // =======================
  function step(t) {
    flashAlpha = Math.max(0, flashAlpha - 0.025);
    flash.style.opacity = flashAlpha.toFixed(3);

    drawBackground(t);
    const elapsed = t - state.phaseStart;

    if (state.phase === PHASE.INTRO) {
      // simple atmospheric silhouettes behind card
      const w=cv.width, h=cv.height;
      drawPerson(w*0.34, h*0.82, PRESETS[8], {alpha:0.16});
      drawPerson(w*0.66, h*0.82, PRESETS[1], {alpha:0.16});
      timeTxt.textContent = "--.--s";
      timeFill.style.width = "0%";
    }

    if (state.phase === PHASE.TITLE) {
      const w=cv.width, h=cv.height;
      drawPerson(w*0.33, h*0.82, PRESETS[8], {alpha:0.22});
      drawPerson(w*0.67, h*0.82, PRESETS[1], {alpha:0.22});
      timeTxt.textContent = "--.--s";
      timeFill.style.width = "0%";
    }

    if (state.phase === PHASE.MEMORY) {
      drawMemoryCard(state.stageData.criminal, state.stageData.shownKeys);
      const left = Math.max(0, (state.memoryMs - elapsed)/1000);
      timeTxt.textContent = `${left.toFixed(2)}s`;
      timeFill.style.width = `${clamp((elapsed/state.memoryMs)*100, 0, 100)}%`;
      if (elapsed >= state.memoryMs) enterWait();
    }

    if (state.phase === PHASE.WAIT) {
      const w=cv.width, h=cv.height;
      const sd = state.stageData;
      const xs = [w*0.25, w*0.5, w*0.75];
      for (let i=0;i<3;i++) drawPerson(xs[i], h*0.82, sd.lineup[i], {alpha:0.18});
      ctx.fillStyle="rgba(255,255,255,0.75)";
      ctx.font="900 44px system-ui, sans-serif";
      ctx.textAlign="center";
      ctx.fillText("……", w/2, h*0.52);

      const left = Math.max(0, (state.waitMs - elapsed)/1000);
      timeTxt.textContent = `${left.toFixed(2)}s`;
      timeFill.style.width = `${clamp((elapsed/state.waitMs)*100, 0, 100)}%`;
      if (elapsed >= state.waitMs) enterPlay();
    }

    if (state.phase === PHASE.PLAY) {
      const w=cv.width, h=cv.height;
      const sd = state.stageData;
      const xs = [w*0.25, w*0.5, w*0.75];
      for (let i=0;i<3;i++) drawPerson(xs[i], h*0.82, sd.lineup[i], {alpha:0.96});

      const leftMs = Math.max(0, state.playMs - elapsed);
      timeTxt.textContent = `${(leftMs/1000).toFixed(2)}s`;
      timeFill.style.width = `${clamp((elapsed/state.playMs)*100, 0, 100)}%`;

      ctx.fillStyle="rgba(255,255,255,0.72)";
      ctx.font="900 22px system-ui, sans-serif";
      ctx.textAlign="center";
      ctx.fillText("V / B / N で撃て", w/2, h*0.18);

      if (leftMs <= 0) timeOut();
    }

    if (state.phase === PHASE.RESULT) {
      const w=cv.width, h=cv.height;
      const sd = state.stageData;
      const xs = [w*0.25, w*0.5, w*0.75];

      for (let i=0;i<3;i++){
        const highlight = (i===state.correctPos);
        const alpha = (state.pickedPos===i || highlight) ? 1.0 : 0.42;
        drawPerson(xs[i], h*0.82, sd.lineup[i], {alpha, highlight});
      }

      ctx.textAlign="center";
      if (state.lastResult==="OK") {
        ctx.fillStyle="rgba(255,255,255,0.94)";
        ctx.font="900 56px system-ui, sans-serif";
        ctx.fillText("HIT", w/2, h*0.42);
        ctx.font="800 20px system-ui, sans-serif";
        ctx.fillStyle="rgba(255,255,255,0.70)";
        const dt = (state.answerAt - state.spawnTime)/1000;
        ctx.fillText(`${dt.toFixed(3)}s`, w/2, h*0.48);
      } else if (state.lastResult==="NG") {
        ctx.fillStyle="rgba(255,255,255,0.94)";
        ctx.font="900 56px system-ui, sans-serif";
        ctx.fillText("MISS", w/2, h*0.42);
      } else {
        ctx.fillStyle="rgba(255,255,255,0.94)";
        ctx.font="900 56px system-ui, sans-serif";
        ctx.fillText("TIME UP", w/2, h*0.42);
      }

      timeTxt.textContent = "—";
      timeFill.style.width = "100%";

      if (elapsed >= state.resultMs) nextStage();
    }

    if (state.phase === PHASE.FINISH) {
      const w=cv.width, h=cv.height;
      drawPerson(w*0.33, h*0.82, PRESETS[3], {alpha:0.18});
      drawPerson(w*0.67, h*0.82, PRESETS[6], {alpha:0.18});
      timeTxt.textContent = "--.--s";
      timeFill.style.width = "0%";
    }

    updateHud();
    requestAnimationFrame(step);
  }

  // =======================
  //   Start
  // =======================
  loadBest();
  enterIntro();          // ✅ 最初は「早撃ちしますか？」へ
  showCenter(true);
  refreshButtons();
  requestAnimationFrame(step);

})();
</script>
</body>
</html>